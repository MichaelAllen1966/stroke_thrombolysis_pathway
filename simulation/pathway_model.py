"""
Model version 170430a


Model description
-----------------

Model to calculate thrombolysis rates and additional good ouctomes.
Outcome data based on onset-to-treatment times using results from:

Emberson et al (2014) Effect of treatment delay, age, and stroke severity on the effects of 
intravenous thrombolysis with alteplase for acute ischaemic stroke: a meta-analysis of individual 
patient data from randomised trials. Lancet. Volume 384(9958), 1929â€“1935. 

Data model runs from is stored in hospital_performance.csv. See 'README_input_data_fields.txt' for
more details. This file is converted to a pandas dataframe and passed to the model function.
The same columns could be generated by other means (other than csv) and passed to the function.
A results dataframe is returned from the model function. In the code below this is then saved as 
a csv.

The model runs 100 years for each scenario. Results returned are median with 5% and 95% 
percentiles, and mean with 95% confidence limits. The 5% and 95% percentiles are intended to show
the normal expected variation from year to year (9 out of 10 years would be expected to be within 
the limits). The mean and 95% confidence limits show the confidence of predicting the mean result 
given 100 years of trials. The error reflects year-to-year variation and does not reflect potential
erros in the underlying data for the model.


Model code and dependencies
---------------------------

This code is written in Python 3.6 (but will probably work in earlier versions of Python 3)
Dependencies are standard Python modules (all of which are automatically available if Python is 
installed using the Anaconda Python distribution):
    numpy
    pandas
    scipy
    math


"""

# import required modules
import numpy as np
import pandas as pd
from math import sqrt
from scipy import stats 


def main():
    
    # Time module used to monitor running time of program
    import time
    time_start = time.time()
    
    # set results file name (by default saved in same directory as code run from)
    results_file_name = 'results/test_results.csv'
    
    # load data from csv and store in pandas dataframe
    hospital_performance = pd.read_csv('data/hospital_performance.csv', index_col=0)
    
    # Save results dataframe    
    results = model_ssnap_pathway_scenarios(hospital_performance)
    results.to_csv(results_file_name)
   
    time_end = time.time()
    print('Completed. Time taken (seconds): ', int(time_end - time_start))
    
    
def model_ssnap_pathway_scenarios(hospital_performance):       

    # %% Set up constants
    
    allowed_onset_to_needle = (270, 180)  # for under 80 and 80+
    allowed_overrun_for_slow_scan_to_needle = 15  # minutes
    good_outcome_base = (0.3499, 0.1318)  # proportion  good ouctomes <80/80+
    scenario_counter = 0
    trials = 100
    
    # Set up dataframes
    
    results_columns = [
        'Baseline_good_outcomes_(median)',
        'Baseline_good_outcomes_per_1000_patients_(low_5%)',
        'Baseline_good_outcomes_per_1000_patients_(high_95%)',
        'Baseline_good_outcomes_per_1000_patients_(mean)',
        'Baseline_good_outcomes_per_1000_patients_(stdev)',
        'Baseline_good_outcomes_per_1000_patients_(95ci)',
        'Percent_Thrombolysis_(median%)',
        'Percent_Thrombolysis_(low_5%)',
        'Percent_Thrombolysis_(high_95%)',
        'Percent_Thrombolysis_(mean)',
        'Percent_Thrombolysis_(stdev)',
        'Percent_Thrombolysis_(95ci)',
        'Additional_good_outcomes_per_1000_patients_(median)',
        'Additional_good_outcomes_per_1000_patients_(low_5%)',
        'Additional_good_outcomes_per_1000_patients_(high_95%)',
        'Additional_good_outcomes_per_1000_patients_(mean)',
        'Additional_good_outcomes_per_1000_patients_(stdev)',
        'Additional_good_outcomes_per_1000_patients_(95ci)']
    
    results_df = pd.DataFrame(columns=results_columns)
    
    # trial dataframe is set up each scenario, but define column names here
    trial_columns = ['Baseline_good_outcomes',
                     'Rx',
                     'Additional_good_outcomes']
   
   
    # %% Iterate through hospitals
    for hospital in hospital_performance.iterrows():
        scenario_counter += 1
        print('Scenario %d' % scenario_counter)
    
        # %% Get data for one hospital
        hospital_name = hospital[0]
        hospital_data = hospital[1]
        run_data = hospital_data
    
        # Set up trial results dataframe
        trial_df = pd.DataFrame(columns=trial_columns)
    
        for trial in range(trials):
            # %% Set up numpy table
            patient_array = []
            patients_per_run = int(run_data['arrivals_per_year'])
            patient_array = np.zeros((patients_per_run, 23))
    
            # Patint array columns:
            # 0: Patient aged 80+
            # 1: Allowable onset-to-needle
            # 2: Onset time known
            # 3: Onset to arrival is less than 4 hours
            # 4: Onset known and is less than 4 hours
            # 5: Onset to arrival minutes
            # 6: Arrival to scan is less than 4 hours
            # 7: Arrival to scan minutes
            # 8: Minutes left to thrombolyse
            # 9: Onset time known and time (30min) left to thrombolyse
            # 10: Ischaemic stroke
            # 11: Sutibale for thrombolysis
            # 12: Thrombolysis given
            # 13: Scan to needle time
            # 14: onset to needle time
            # 15: baseline probability of good outcome
            # 16: baseline odds of good outcome
            # 17: improved odds-ratio of good outcome assuming thrombolysis given
            # 18: adjusted odds of good outcome assuming thrombolysis given
            # 19: adjusted probability of good outcome assuming thrombolysis given
            # 20: improved probability of good outcome (is set to zero when no thrombolysis given)
            # 21: individual good outcome due to thrombolysis (not currently used)
            # 22: individual good outcome if no thrombolysis given (not currently used)
    
    
            # Assign whether 80 or over
            patient_array[:, 0] = np.random.binomial(1, run_data['80_plus'], patients_per_run)
    
            # Assign allowable onset to needs
            patient_array[patient_array[:, 0] == 0, 1] = allowed_onset_to_needle[0]
            patient_array[patient_array[:, 0] == 1, 1] = allowed_onset_to_needle[1]
    
            # Assign onset time known
            patient_array[:, 2] = (np.random.binomial(1, run_data['onset_known'], 
                patients_per_run) == 1)
    
            # Assign onset to arrival is less than 4 hours (assigned to all patients)
            patient_array[:, 3] = (np.random.binomial(1, run_data['known_arrival_within_4hrs'], 
                patients_per_run))
    
            # Onset known and is within 4 hours
            patient_array[:, 4] = patient_array[:, 2] * patient_array[:, 3]
    
            # Assign onset to arrival time (log normal distribution) 
            mu = run_data['onset_arrival_mins_mu']  # mean as ln
            sigma = run_data['onset_arrival_mins_sigma']  # standard deviation as ln
            patient_array[:, 5] = np.random.lognormal(mu, sigma, patients_per_run)
    
            # Assign arrival to scan is less than 4 hours
            patient_array[:, 6] = (np.random.binomial(1, run_data['scan_within_4_hrs'],
                patients_per_run))
    
            # Assign onset arrival to scan time (log normal distribution) 
            mu = run_data['arrival_scan_arrival_mins_mu']  # mean as ln
            sigma = run_data['arrival_scan_arrival_mins_sigma']  # standard deviation as ln
            patient_array[:, 7] = np.random.lognormal(mu, sigma, patients_per_run)
    
            # Minutes left to thrombolyse after scan
            patient_array[:, 8] = patient_array[:, 1] - (patient_array[:, 5] + patient_array[:, 7])
    
            # Onset time known, scan in 4 hours and time ime left to thrombolyse (1 to proceed,
            # 0 not to proceed)
            patient_array[:, 9] = (patient_array[:, 6] * patient_array[:, 4] * 
                (patient_array[:, 8] >= 20))
    
            # Ischaemic_stroke
            patient_array[:, 10] = (np.random.binomial(1, run_data['ischaemic_stroke'], 
                patients_per_run))
    
            # Eligable for thrombolysis (proportion of ischaemic patients eligable for thrombolysis 
            # when scanned with 30 min left)
            patient_array[:, 11] = (np.random.binomial(1, run_data['ischaemic_eligable'],
                patients_per_run))
    
            # Thrombolysis planned (checks whether this us 30 min left, ischaemic stroke & 
            # patient considerd eligable for thrombolysis if scanned in time
            patient_array[:, 12] = patient_array[:, 9] * patient_array[:, 10] * patient_array[:, 11]
    
            # scan to needle
            mu = run_data['scan_needle_mins_mu']  # mean as ln
            sigma = run_data['scan_needle_mins_sigma']  # standard deviation as ln
            patient_array[:, 13] = np.random.lognormal(mu, sigma, patients_per_run)
    
            # Onset to needle and check whether in time (inclusing allowed over-run)
            patient_array[:, 14] = patient_array[:, 5] + patient_array[:, 7] + patient_array[:, 13]
            needle_in_time = (patient_array[:, 14] < patient_array[:, 1] + 
                allowed_overrun_for_slow_scan_to_needle)
    
            # Update thrombolysis planned if scan-to-needle time means that thrombolysis cannot be 
            # given in time
            patient_array[:, 12] *= needle_in_time
    
            # Set baseline probability good outcome (based on age group)
            patient_array[patient_array[:, 0] == 0, 15] = good_outcome_base[0]
            patient_array[patient_array[:, 0] == 1, 15] = good_outcome_base[1]
    
            # Convert baseline probability to baseline odds
            patient_array[:, 16] = patient_array[:, 15] / (1 - patient_array[:, 15])
    
            # Calculate odds ratio based on time to treatment
            patient_array[:, 17] = 10 ** (0.326956 + (-0.00086211 * patient_array[:, 14]))
    
            # Adjust odds of good outcome
            patient_array[:, 18] = patient_array[:, 16] * patient_array[:, 17]
    
            # Convert odds back to probability
            patient_array[:, 19] = patient_array[:, 18] / (1 + patient_array[:, 18])
    
            # Improved probability of good outcome (calc changed probability then multiply by 
            # whether thrombolysis given)
            x = (patient_array[:, 19] - patient_array[:, 15]) * patient_array[:, 12]
            y = np.zeros(patients_per_run)
            # remove any negative probabilities calculated (can occur if long treatment windows set)
            patient_array[:, 20] = np.amax([x, y], axis=0)
    
            # Individual good ouctome due to thrombolysis 
            # This is not currently used in the analysis
            patient_array[:, 21] = np.random.binomial(1, patient_array[:, 20], patients_per_run)
    
            # Individual outcomes if no treatment given 
            patient_array[:, 22] = np.random.binomial(1, patient_array[:, 15], patients_per_run)
    
            # Calculate overall thrombolysis rate
            thrmobolysis_percent = patient_array[:, 12].mean() * 100
    
            # Baseline good outcomes per 1000 pateints
            baseline_good_outcomes_per_1000_patients = ((patient_array[:, 22].sum() / 
                patients_per_run) * 1000)
    
            # Calculate overall expected extra good outcomes (sum probabilities of good outcomes)
            additional_good_outcomes_per_1000_patients = ((patient_array[:, 20].sum() / 
                patients_per_run) * 1000)
    
            # Save scenario results to dataframe
            result = [baseline_good_outcomes_per_1000_patients, thrmobolysis_percent,
                      additional_good_outcomes_per_1000_patients]
            trial_df.loc[trial] = result
    
        trial_result = ([
            trial_df['Baseline_good_outcomes'].median(),
            trial_df['Baseline_good_outcomes'].quantile(0.05),
            trial_df['Baseline_good_outcomes'].quantile(0.95),
            trial_df['Baseline_good_outcomes'].mean(),
            trial_df['Baseline_good_outcomes'].std(),
            (trial_df['Baseline_good_outcomes'].mean() - 
                stats.norm.interval(0.95, loc=trial_df['Baseline_good_outcomes'].mean(),
                scale=trial_df['Baseline_good_outcomes'].std() / sqrt(trials))[0]),
            trial_df['Rx'].median(),
            trial_df['Rx'].quantile(0.05),
            trial_df['Rx'].quantile(0.95),
            trial_df['Rx'].mean(),
            trial_df['Rx'].std(),
            (trial_df['Rx'].mean() - stats.norm.interval(0.95, loc=trial_df['Rx'].mean(),
                scale=trial_df['Rx'].std() / sqrt(trials))[0]),
            trial_df['Additional_good_outcomes'].median(),
            trial_df['Additional_good_outcomes'].quantile(0.05),
            trial_df['Additional_good_outcomes'].quantile(0.95),
            trial_df['Additional_good_outcomes'].mean(),
            trial_df['Additional_good_outcomes'].std(),
            (trial_df['Additional_good_outcomes'].mean() - 
                stats.norm.interval(0.95, loc=trial_df['Additional_good_outcomes'].mean(),
                scale=trial_df['Additional_good_outcomes'].std() / sqrt(trials))[0])
            ])
        # add scenario results to results dataframe
        results_df.loc[hospital_name] = trial_result
    
    # at enf of all scenarios round all results to 2 decimal places and retrun results    
    results_df = results_df.round(2)
    return (results_df)
   

# Code entry point
# Main function run only if code loaded as main program. If code imported as module then main
# function will not run, but functions are available to code that has imported module.    
if __name__ == '__main__':
    main()
